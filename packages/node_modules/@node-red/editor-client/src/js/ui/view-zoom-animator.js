/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.view.zoomAnimator = (function() {
    
    /**
     * Easing function for smooth deceleration
     * Creates natural-feeling animation curves
     * @param {number} t - Progress from 0 to 1
     * @returns {number} - Eased value from 0 to 1
     */
    function easeOut(t) {
        // Cubic ease-out for smooth deceleration
        return 1 - Math.pow(1 - t, 3);
    }
    
    /**
     * Animate values using requestAnimationFrame with easing
     * Based on Excalidraw's implementation for smooth zoom transitions
     * 
     * @param {Object} options - Animation options
     * @param {Object} options.fromValues - Starting values object
     * @param {Object} options.toValues - Target values object
     * @param {Function} options.onStep - Callback for each animation frame
     * @param {number} [options.duration=250] - Animation duration in ms
     * @param {Function} [options.interpolateValue] - Custom interpolation function
     * @param {Function} [options.onStart] - Animation start callback
     * @param {Function} [options.onEnd] - Animation end callback
     * @param {Function} [options.onCancel] - Animation cancel callback
     * @returns {Function} - Cancel function to stop animation
     */
    function easeToValuesRAF(options) {
        const {
            fromValues,
            toValues,
            onStep,
            duration = 250,
            interpolateValue,
            onStart,
            onEnd,
            onCancel
        } = options;
        
        let startTime = null;
        let animationId = null;
        let cancelled = false;
        
        function step(timestamp) {
            if (cancelled) {
                return;
            }
            
            if (!startTime) {
                startTime = timestamp;
                if (onStart) {
                    onStart();
                }
            }
            
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOut(progress);
            
            const interpolatedValues = {};
            
            for (const key in fromValues) {
                const from = fromValues[key];
                const to = toValues[key];
                
                if (interpolateValue && key === 'zoom') {
                    // Special interpolation for zoom to feel more natural
                    // Exponential interpolation preserves relative zoom feel
                    interpolatedValues[key] = from * Math.pow(to / from, easedProgress);
                } else {
                    // Linear interpolation for other values
                    interpolatedValues[key] = from + (to - from) * easedProgress;
                }
            }
            
            onStep(interpolatedValues);
            
            if (progress < 1) {
                animationId = requestAnimationFrame(step);
            } else {
                if (onEnd) {
                    onEnd();
                }
            }
        }
        
        animationId = requestAnimationFrame(step);
        
        // Return cancel function
        return function cancel() {
            cancelled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (onCancel) {
                onCancel();
            }
        };
    }
    
    /**
     * Calculate smooth zoom delta with acceleration
     * Provides consistent zoom speed regardless of input device
     * 
     * @param {number} currentScale - Current zoom scale
     * @param {number} delta - Input delta (wheel, gesture, etc)
     * @param {boolean} isTrackpad - Whether input is from trackpad
     * @returns {number} - Calculated zoom delta
     */
    function calculateZoomDelta(currentScale, delta, isTrackpad) {
        // Normalize delta across different input devices
        let normalizedDelta = delta;
        
        if (isTrackpad) {
            // Trackpad deltas are typically smaller and more frequent
            normalizedDelta = delta * 0.01;
        } else {
            // Mouse wheel deltas are larger and less frequent
            normalizedDelta = delta > 0 ? 0.1 : -0.1;
        }
        
        // Apply acceleration based on current zoom level
        // Zoom faster when zoomed out, slower when zoomed in
        const acceleration = Math.max(0.5, Math.min(2, 1 / currentScale));
        
        return normalizedDelta * acceleration;
    }
    
    /**
     * Gesture state management for consistent focal points
     */
    const gestureState = {
        active: false,
        initialFocalPoint: null,  // Will store workspace coordinates
        initialScale: 1,
        currentScale: 1,
        lastDistance: 0,
        scrollPosAtStart: null,    // Store initial scroll position
        scaleFatorAtStart: 1       // Store initial scale factor
    };
    
    /**
     * Start a zoom gesture with fixed focal point
     * @param {Array} focalPoint - [x, y] coordinates of focal point in workspace
     * @param {number} scale - Initial scale value
     * @param {Array} scrollPos - Current scroll position [x, y]
     * @param {number} currentScaleFactor - Current scale factor for coordinate conversion
     */
    function startGesture(focalPoint, scale, scrollPos, currentScaleFactor) {
        gestureState.active = true;
        // Store the focal point in workspace coordinates for stability
        // This ensures the point remains fixed even if scroll changes due to canvas edge constraints
        if (focalPoint && scrollPos && currentScaleFactor) {
            gestureState.initialFocalPoint = [
                (scrollPos[0] + focalPoint[0]) / currentScaleFactor,
                (scrollPos[1] + focalPoint[1]) / currentScaleFactor
            ];
            gestureState.scrollPosAtStart = [...scrollPos];
            gestureState.scaleFatorAtStart = currentScaleFactor;
        } else {
            gestureState.initialFocalPoint = focalPoint ? [...focalPoint] : null;
        }
        gestureState.initialScale = scale;
        gestureState.currentScale = scale;
        return gestureState;
    }
    
    /**
     * Update gesture maintaining fixed focal point
     * @param {number} newScale - New scale value
     * @returns {Object} - Gesture state with fixed focal point
     */
    function updateGesture(newScale) {
        if (!gestureState.active) {
            return null;
        }
        
        gestureState.currentScale = newScale;
        
        return {
            scale: newScale,
            focalPoint: gestureState.initialFocalPoint,
            active: gestureState.active
        };
    }
    
    /**
     * End the current gesture
     */
    function endGesture() {
        gestureState.active = false;
        gestureState.initialFocalPoint = null;
        gestureState.lastDistance = 0;
    }
    
    /**
     * Check if a gesture is currently active
     */
    function isGestureActive() {
        return gestureState.active;
    }
    
    /**
     * Get the fixed focal point for the current gesture
     * @param {Array} currentScrollPos - Current scroll position [x, y]
     * @param {number} currentScaleFactor - Current scale factor
     * @returns {Array} - Focal point in screen coordinates or null
     */
    function getGestureFocalPoint(currentScrollPos, currentScaleFactor) {
        if (!gestureState.initialFocalPoint) {
            return null;
        }
        
        // If we stored workspace coordinates, convert back to screen coordinates
        if (gestureState.scrollPosAtStart && currentScrollPos && currentScaleFactor) {
            // Convert workspace coordinates back to current screen coordinates
            return [
                gestureState.initialFocalPoint[0] * currentScaleFactor - currentScrollPos[0],
                gestureState.initialFocalPoint[1] * currentScaleFactor - currentScrollPos[1]
            ];
        }
        
        return gestureState.initialFocalPoint;
    }
    
    return {
        easeOut: easeOut,
        easeToValuesRAF: easeToValuesRAF,
        calculateZoomDelta: calculateZoomDelta,
        gestureState: gestureState,
        startGesture: startGesture,
        updateGesture: updateGesture,
        endGesture: endGesture,
        isGestureActive: isGestureActive,
        getGestureFocalPoint: getGestureFocalPoint
    };
})();